<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Practice for Spelling Bee</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>
<body>
    <h1>Practice for Spelling Bee</h1>
    <div id="practice-area">
        <p>Now playing word: <span id="word-count">0/0</span></p>
        <p>Score: Correct: <span id="correct-count">0</span> | Incorrect: <span id="incorrect-count">0</span></p>
        <input type="text" id="word-input" placeholder="Type the word here">
        <button id="submit-btn">Submit</button>
    </div>
    <div id="controls">
        <button id="start-btn">Start Practice</button>
        <button id="next-btn">Next Word</button>
        <button id="repeat-btn">Repeat</button>
        <button id="randomize-btn">Randomize</button>
        <button id="reset-btn">Reset</button>
    </div>
    <a href="{{ url_for('results') }}" id="results-link">Results</a>
    <p id="completion-message" style="display: none;">Practice complete!</p>

    <script>
        let words = [];
        let currentWordIndex = -1;
        let audio = new Audio();
        let correctCount = 0;
        let incorrectCount = 0;

        // Fetch words from server and initialize the app
        fetch('/words')
            .then(response => response.json())
            .then(data => {
                words = data;
                initializeApp();
            });

        function initializeApp() {
            const savedState = JSON.parse(localStorage.getItem('spellingBeePracticeState'));
            if (savedState) {
                currentWordIndex = savedState.currentWordIndex;
                correctCount = savedState.correctCount;
                incorrectCount = savedState.incorrectCount;
                words = savedState.words;
            }
            updateWordCount();
            updateScoreDisplay();
            if (currentWordIndex >= 0) {
                playCurrentWord();
            }
        }

        function updateWordCount() {
            document.getElementById('word-count').textContent = `${currentWordIndex + 1}/${words.length}`;
        }

        function updateScoreDisplay() {
            document.getElementById('correct-count').textContent = correctCount;
            document.getElementById('incorrect-count').textContent = incorrectCount;
        }

        function playCurrentWord() {
            if (currentWordIndex >= 0 && currentWordIndex < words.length) {
                audio.src = `/audio/${words[currentWordIndex]}.mp3`;
                audio.play();
            }
        }

        function updateResults(isCorrect, word, userInput) {
            let results = JSON.parse(localStorage.getItem('spellingBeeResults')) || { correct: [], incorrect: [] };
            if (isCorrect) {
                results.correct.push(word);
            } else {
                results.incorrect.push({ word: word, userInput: userInput });
            }
            localStorage.setItem('spellingBeeResults', JSON.stringify(results));
        }

        function saveState() {
            const state = {
                currentWordIndex,
                correctCount,
                incorrectCount,
                words
            };
            localStorage.setItem('spellingBeePracticeState', JSON.stringify(state));
        }

        function checkAnswer() {
            const userInput = document.getElementById('word-input').value.trim().toLowerCase();
            const correctWord = words[currentWordIndex].toLowerCase();
            if (userInput === correctWord) {
                correctCount++;
                updateResults(true, correctWord, userInput);
            } else {
                incorrectCount++;
                updateResults(false, correctWord, userInput);
            }
            updateScoreDisplay();
            document.getElementById('word-input').value = '';
            saveState();
        }

        function nextWord() {
            currentWordIndex++;
            if (currentWordIndex >= words.length) {
                document.getElementById('completion-message').style.display = 'block';
                return;
            }
            updateWordCount();
            playCurrentWord();
            saveState();
        }

        document.getElementById('start-btn').addEventListener('click', () => {
            currentWordIndex = -1;
            nextWord();
        });

        document.getElementById('next-btn').addEventListener('click', nextWord);

        document.getElementById('repeat-btn').addEventListener('click', playCurrentWord);

        document.getElementById('randomize-btn').addEventListener('click', () => {
            const remainingWords = words.slice(currentWordIndex + 1);
            for (let i = remainingWords.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [remainingWords[i], remainingWords[j]] = [remainingWords[j], remainingWords[i]];
            }
            words = [...words.slice(0, currentWordIndex + 1), ...remainingWords];
            saveState();
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            currentWordIndex = -1;
            correctCount = 0;
            incorrectCount = 0;
            document.getElementById('word-input').value = '';
            document.getElementById('completion-message').style.display = 'none';
            localStorage.removeItem('spellingBeeResults');
            localStorage.removeItem('spellingBeePracticeState');
            updateWordCount();
            updateScoreDisplay();
        });

        document.getElementById('submit-btn').addEventListener('click', () => {
            checkAnswer();
            nextWord();
        });

        document.getElementById('word-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                checkAnswer();
                nextWord();
            }
        });

        // Save state before leaving the page
        window.addEventListener('beforeunload', saveState);
    </script>
</body>
</html>